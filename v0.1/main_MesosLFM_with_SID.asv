clc, clear
close all

%% this file is the main file for the meso-sLFM calcium data processing.
%  this pipeline contains from reading to calcium sensing.

%  last update: 5/11/2021. YZ

addpath(genpath('utility'))
outdir = 'out\\crystal_skull_std_dense';
mkdir(outdir)
%%
% colormap
color_scheme_npg = [...
    0.9020    0.2941    0.2078; ...
    0.3020    0.7333    0.8353; ...
         0    0.6275    0.5294; ...
    0.2353    0.3294    0.5333; ...
    0.9529    0.6078    0.4980; ...
    0.5176    0.5686    0.7059; ...
    0.5686    0.8196    0.7608; ...
    0.8627         0         0; ...
    0.4941    0.3804    0.2824; ...
    0.6902    0.6118    0.5216 ];

%% data loader
% PSF Path
psfpath = 'Z:/PSF/psf_zww/20200125_genepsf_3.1746x_sim_neg400T400_dz4_15Nnum_OSR5';


% Wigner Path (i.e. raw path)
wdfdata_folder1 = 'D:/RichardW2021/RUSH3DResult/Preprocess/';
wdfdata_folder2 = rawdata_folder2;
wdfdata_folder12 = strcat(wdfdata_folder1, wdfdata_folder2);
wdfdata_folder3 = strcat(wdfdata_folder12, rawdatafilename_perfix,'/');
wdfdata_folder4 = strcat(wdfdata_folder3, 'WDF/');

wdfname = [wdfdata_folder4,'rank1__No0.tif'];
%% parameters
%  reconstruction parameters
param.M = 3.1746; %% Magnification = 3.17
param.Nshift = 3; %% Scanning Times = 3 x 3
param.Nnum = 15; %% 15 x 15 pixels behind each MicroLen
param.PSF_broader = 276; %% Cut PSF each side for 276 pixels;
param.PSF_size = 5; %%£¨x,y,u,v,z£©---->(x,y,u,z) no meaning
param.Block_num = 0; %% no meaning


% ------------------------- Reconstruction parameter ------------------------- % 
param.Angle_range = 25; %% About 25 Angle views within the iteration
param.AOstar = 1; %% 1 for DAO; 0 for no DAO 
param.maxIter = 3; %% Max iteration times: 2 or 3 is enough
param.rotWDF = 0; %% no meaning
param.DownSampling_for_PSF = 1; %% Downsampling rate for PSF
param.UpSamplingRate_for_WDF = Nnum/Nshift/DownSampling_for_PSF; %% UpsamlpingRate for WDF, which is corresponding to the PSF Size.
param.psf_layer = [1:2:51,52:1:151,153:2:201]; % PSF to be loaded []

% ------------------------- DAO parameter ---------------------------
param.defocus = 1; %% 1 for defocus, 0 for no defocus
param.Nbx = 5; param.Nby = 5; %% Block apart 5 x 5 pieces when DAO 
param.num_block= 18 ;    %% Axial block for 10 when forword propagate 
param.threshhold = 25;  %% Shift should not be allowed to exceed [-25,25]
param.sidelobe=9; %% Each 

param.estimate_patch_size = 700;

param.pixel_size = 1.2e-6; % lateral pixel size
param.per_slice_depth = 4e-6; % axial slice depth range

% multi-scale depth calculation
psf_layer_position = [1 : 2 : 51, 52 : 1 : 151, 153 : 2 : 201];

%% realign 
%  require: per-image realignment
realign_param.Nshift = 3;
realign_param.Nnum = 15;

realign_param.large_cycle = 24; %% 24 x 40 Images will be loaded;
realign_param.small_cycle = 40; %% one stack contains 40 LF Images;
realign_param.maxIter = 10; %% Maximum times for Iterate rank normal one

summary_image = preprocessing_module(realign_param, data_path, wdf_path);


%% summary image generation
% current we use rank-1 backgropund detrending + std


%% reconstruction module
curr_volume = reconstruction_module(param,wdfname);
curr_volume = double(curr_volume);
curr_volume = curr_volume  / max(curr_volume(:));

%% neuron segmentation generation module
[global_A_in, global_center] = segmentation_module(curr_volume, seed_param);


%% seed module
% generate seed template for iterations


%% background rejection 
%  subtract background informations in the target volume size
%  reconstruct the side view and project to other views?

%% main iteration module
% shall we fully use the information? in my opinion there is no need to
% fully use everything thing
% this is necessary since the neuron overlapping


% for querying data we might can read it in local positions


% require: temporal information extraction from target wigner, typically
% 5-10 wigners will be used.
% note only othogonal view is required.


%  



%% load central view stack
scale_up_factor = 1;
movie_name = 'test_CV.0.tif';
movie = loadtiff(sprintf('%s\\%s', file_path, movie_name));
movie = double(movie);
movie = movie / max(movie(:));

movie = imresize3(movie, scale_up_factor);
[movie_size_h, movie_size_w, movie_size_T] = size(movie);



%% temporal signal sensing with CNMFE type with LFM seed.

gSig = 2* scale_up_factor;           % pixel, gaussian width of a gaussian kernel for filtering the data. 0 means no filtering
gSiz = 5* scale_up_factor;          % pixel, neuron diameter
ssub = 1* scale_up_factor;           % spatial downsampling factor
with_dendrites = false;   % with dendrites or not
if with_dendrites
    % determine the search locations by dilating the current neuron shapes
    updateA_search_method = 'dilate';  %#ok<UNRCH>
    updateA_bSiz = 5;
    updateA_dist = 3; % default of CNMFE
else
    % determine the search locations by selecting a round area
    % here we use other method
    updateA_search_method = 'other'; %#ok<UNRCH> %
    updateA_dist = 5;
    updateA_bSiz = 3;
end
spatial_constraints = struct('connected', true, 'circular', false);  % you can include following constraints: 'circular'
spatial_algorithm = 'hals_thresh';

% -------------------------      TEMPORAL     -------------------------  %
Fs = 1;             % frame rate
tsub = 1;           % temporal downsampling factor
deconv_flag = true;     % run deconvolution or not 
deconv_options = struct('type', 'ar1', ... % model of the calcium traces. {'ar1', 'ar2'}
    'method', 'foopsi', ... % method for running deconvolution {'foopsi', 'constrained', 'thresholded'}
    'smin', -5, ...         % minimum spike size. When the value is negative, the actual threshold is abs(smin)*noise level
    'optimize_pars', true, ...  % optimize AR coefficients
    'optimize_b', true, ...% optimize the baseline);
    'max_tau', 100);    % maximum decay time (unit: frame);

nk = 3;             % detrending the slow fluctuation. usually 1 is fine (no detrending)
% when changed, try some integers smaller than total_frame/(Fs*30)
detrend_method = 'spline';  % compute the local minimum as an estimation of trend.

% -------------------------     BACKGROUND    -------------------------  %
bg_model = 'ring';  % model of the background {'ring', 'svd'(default), 'nmf'}
nb = 1;             % number of background sources for each patch (only be used in SVD and NMF model)
ring_radius = 10* scale_up_factor;  % when the ring model used, it is the radius of the ring used in the background model.
%otherwise, it's just the width of the overlapping area
num_neighbors = []; % number of neighbors for each neuron
bg_ssub = 2;        % downsample background for a faster speed 

% -------------------------      MERGING      -------------------------  %
show_merge = false;  % if true, manually verify the merging step
merge_thr = 0.0;     % thresholds for merging neurons; [spatial overlap ratio, temporal correlation of calcium traces, spike correlation]
method_dist = 'max';   % method for computing neuron distances {'mean', 'max'}
dmin = 3* scale_up_factor;       % minimum distances between two neurons. it is used together with merge_thr
dmin_only = 5* scale_up_factor;  % merge neurons if their distances are smaller than dmin_only.
merge_thr_spatial = [0.8, 0.4, -inf];  % merge components with highly correlated spatial shapes (corr=0.8) and small temporal correlations (corr=0.1)

% -------------------------  INITIALIZATION   -------------------------  %
% K = 140;             % maximum number of neurons per patch. when K=[], take as many as possible.
min_corr = 0;     % minimum local correlation for a seeding pixel
min_pnr = 0;       % minimum peak-to-noise ratio for a seeding pixel
min_pixel = 1;      % minimum number of nonzero pixels for each neuron
bd = 0;             % number of rows/columns to be ignored in the boundary (mainly for motion corrected data)
frame_range = [];   % when [], uses all frames
save_initialization = false;    % save the initialization procedure as a video.
use_parallel = false;    % use parallel computation for parallel computing
show_init = true;   % show initialization results
choose_params = false; % manually choose parameters
center_psf = true;  % set the value as true when the background fluctuation is large (usually 1p data)
% set the value as false when the background fluctuation is small (2p)

% -------------------------  Residual   -------------------------  %
min_corr_res = 0.7;
min_pnr_res = 6;
seed_method_res = 'auto';  % method for initializing neurons from the residual
update_sn = true;

% ----------------------  WITH MANUAL INTERVENTION  --------------------  %
with_manual_intervention = false;

% -------------------------  FINAL RESULTS   -------------------------  %
save_demixed = true;    % save the demixed file or not
kt = 3;                 % frame intervals
obj.options = CNMFSetParms();
obj.options = CNMFSetParms(obj.options, 'gSig', gSig, ...       % -------- spatial --------
    'gSiz', gSiz, ...
    'ring_radius', ring_radius, ...
    'ssub', ssub, ...
    'search_method', updateA_search_method, ...
    'bSiz', updateA_bSiz, ...
    'dist', updateA_bSiz, ...
    'spatial_constraints', spatial_constraints, ...
    'spatial_algorithm', spatial_algorithm, ...
    'tsub', tsub, ...                       % -------- temporal --------
    'deconv_flag', deconv_flag, ...
    'deconv_options', deconv_options, ...
    'nk', nk, ...
    'detrend_method', detrend_method, ...
    'background_model', bg_model, ...       % -------- background --------
    'nb', nb, ...
    'ring_radius', ring_radius, ...
    'num_neighbors', num_neighbors, ...
    'bg_ssub', bg_ssub, ...
    'merge_thr', merge_thr, ...             % -------- merging ---------
    'dmin', dmin, ...
    'method_dist', method_dist, ...
    'min_corr', min_corr, ...               % ----- initialization -----
    'min_pnr', min_pnr, ...
    'min_pixel', min_pixel, ...
    'bd', bd, ...
    'center_psf', center_psf);

% CNMFE specific
obj.outdir = outdir;
obj.frame_range = [];
obj.P =struct('mat_file', [], 'mat_data', [], 'indicator', '', 'k_options', 0, ...
                'k_snapshot', 0, 'k_del', 0, 'k_merge', 0, 'k_trim', 0, 'sn', [], ...
                'kernel_pars',[], 'k_ids', 0); % note the structure of P
obj.Coor = [];
obj.Fs = 10;

Y = movie;

%% CNMF-E: initialization
% noise estimation

obj.P.sn = CNMFE_estimate_noise(Y, frame_range);
clc
[obj, center, Cn, PNR] = initComponents_with_Ain_no_patch(Y, obj, global_A_in);
% refine spatial
obj = compactSpatial(obj);
if show_init
    figure();
    ax_init= axes();
    imagesc(Cn, [0, 1]); colormap gray;
    hold on;
    plot(center(:, 2), center(:, 1), '.r', 'markersize', 10);
end
axis equal
%
figure, subplot(1, 3, 1), spatial_comp_render(obj.A, global_A_in, [movie_size_h, movie_size_w])
subplot(1, 3, 2), obj = CNMFE_show_contours(obj, 0.99);
subplot(1, 3, 3), temporal_trace_render(obj.C_raw(1 : 100, :), 'k'),sgtitle('after inital')
saveas(gca, sprintf('%s\\after_initial.png', outdir))
%% CNMF-E: background update (1st time)
clc
obj = update_background_no_patch(Y, obj);
% how to illustrate the performance?

% show neuron and activity
figure, subplot(1, 3, 1), spatial_comp_render(obj.A, global_A_in, [movie_size_h, movie_size_w])
subplot(1, 3, 2), obj = CNMFE_show_contours(obj, 0.99);
subplot(1, 3, 3), temporal_trace_render(obj.C_raw(1 : 100, :), 'k'),sgtitle('after bg update')
saveas(gca, sprintf('%s\\after_bg.png', outdir))
%% CNMF-E: spatial update
clc
[obj, global_A_in_update, empty_ind] = update_spatial_no_patch_manual_A_in(Y, global_A_in, obj, update_sn);
obj = update_background_no_patch(Y, obj);

% show neuron and activity
figure, subplot(1, 3, 1), spatial_comp_render(obj.A, global_A_in, [movie_size_h, movie_size_w])
subplot(1, 3, 2), obj = CNMFE_show_contours(obj, 0.99);
subplot(1, 3, 3), temporal_trace_render(obj.C_raw(1 : 100, :), 'k'),sgtitle('after spatial update')
saveas(gca, sprintf('%s\\after_spatial_update.png', outdir))
%%
obj = CNMFE_merge_high_corr(obj, show_merge, merge_thr_spatial);
% show neuron and activity
figure, subplot(1, 3, 1), spatial_comp_render(obj.A, global_A_in,  [movie_size_h, movie_size_w])
subplot(1, 3, 2), obj = CNMFE_show_contours(obj, 0.99); 
subplot(1, 3, 3), temporal_trace_render(obj.C_raw(1 : 100, :), 'k'), sgtitle('after merge update')
saveas(gca, sprintf('%s\\after_merge.png', outdir))
%% CNMF-E temporal
clc
for m=1:2
    % update temporal
    obj = update_temporal_no_patch(Y, obj);
    % delete bad neurons
%     obj = CNMFE_remove_false_positives(obj, false);    
    % merge neurons based on temporal correlation + distances 
%     obj = CNMFE_merge_neurons_dist_corr(obj, show_merge);
end
figure, subplot(1, 3, 1), spatial_comp_render(obj.A, global_A_in,  [movie_size_h, movie_size_w])
subplot(1, 3, 2), obj = CNMFE_show_contours(obj, 0.99);
subplot(1, 3, 3), temporal_trace_render(obj.C_raw(1 : 100, :), 'k'), sgtitle('after temporal update')
saveas(gca, sprintf('%s\\after_temporal.png', outdir))
%% run more iterations
empty_ind_global = empty_ind;
for i = 1 : 3
    i
obj = update_background_no_patch(Y, obj);


[obj, global_A_in_update, empty_ind]  = update_spatial_no_patch_manual_A_in(Y, global_A_in_update, obj, update_sn);

curr_empty_ind_global = reg_gloabl_empy_ind(empty_ind_global, empty_ind);
empty_ind_global = curr_empty_ind_global .* empty_ind_global;
obj = update_temporal_no_patch(Y, obj);
end
% obj = CNMFE_remove_false_positives(obj);
% obj = CNMFE_merge_neurons_dist_corr(obj, show_merge);
% obj = CNMFE_merge_high_corr(obj, show_merge);

valid_seg_global_filt_final = valid_seg_global_filt;
valid_seg_global_filt_final(find(exclude_ind), :) = [];
%%
figure, subplot(1, 3, 1), spatial_comp_render(obj.A, global_A_in, [movie_size_h, movie_size_w])
subplot(1, 3, 2), obj = CNMFE_show_contours(obj, 0.99); % larger parameter, larger countor
subplot(1, 3, 3), temporal_trace_render(obj.C_raw(1 : 100, :), 'k'), sgtitle('after more runs')
saveas(gca, sprintf('%s\\after_more_runs.png', outdir))


%% final plot: 3D neuron distributions in a video
% with AZ changed
avi_filename =[outdir, '\\spatial_video.avi'];
avi_file = VideoWriter(avi_filename);
avi_file.FrameRate = 30;
avi_file.Quality = 100;
% avi_file.CompressionRatio = 1;
% avi_file.VideoCompressionMethod = 'H.264';
avi_file.open();


az_angle = 1 : 720;
el = 19;
figure('Name', 'video', 'position', [100, 100, 400, 300])
for i = 1 : 1 : length(az_angle)
    clf
	plot_3D_distribution(valid_seg_global_filt_final, [size_h, size_w], [1, 2] * pixel_size, ...
                        param.psf_layer * per_slice_depth, 10) 
	view(az_angle(i), el)
    
	temp = getframe(gcf);
%     temp = imresize(temp.cdata, [400, 600]);
    avi_file.writeVideo(temp);
   
end
avi_file.close();   

%% final plot: temporal activity
tmp_C = zscore(obj.C, 0, 2);
figure, imagesc(tmp_C)
pbaspect([1, 2, 1])

% zoom in,
zoom_in_neuron_id = [1000, 1100];
zoom_in_time = [500, 800];
hold on,
rectangle('Position', [zoom_in_time(1), zoom_in_neuron_id(1), ...
                zoom_in_time(2) - zoom_in_time(1), ...
                zoom_in_neuron_id(2) - zoom_in_neuron_id(1)], ...
                'edgecolor', color_scheme_npg(1, :), ...
                'linestyle', '--', ...
                'linewidth', 1)
%%
figure('position', [1, 1, 300, 600]),
temporal_trace_render_simple(tmp_C(zoom_in_neuron_id(1) : zoom_in_neuron_id(2), ...
                         zoom_in_time(1) : zoom_in_time(2)))
colormap('gray')
caxis([-2, 0])
axis off
pbaspect([1, 2, 1])
%% utility function










